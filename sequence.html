<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>音名で入力 - Ocarina Fingering Trainer</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;500;700&display=swap" rel="stylesheet">
<style>
  /* --- デザインシステム --- */
  :root {
    --primary-color: #4a80e2;
    --primary-light: #eaf2ff;
    --background-color: #f7f9fc;
    --surface-color: #ffffff;
    --text-color: #333333;
    --text-light-color: #777777;
    --border-color: #e0e6f0;
    --radius: 12px;
    --shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
    --shadow-light: 0 2px 6px rgba(0, 0, 0, 0.05);
  }

  /* --- 基本設定 --- */
  * { box-sizing: border-box; }
  body {
    font-family: "Noto Sans JP", system-ui, sans-serif;
    margin: 0;
    background: var(--background-color);
    color: var(--text-color);
  }
  .container {
    max-width: 960px;
    margin: 0 auto;
    padding: 1rem 2rem;
  }

  /* --- ヘッダー & ナビゲーション --- */
  header {
    background: var(--surface-color);
    border-bottom: 1px solid var(--border-color);
    padding: 1rem 0;
    margin-bottom: 2rem;
    text-align: center;
  }
  header h1 {
    font-size: 1.5rem;
    font-weight: 700;
    margin: 0 0 1rem 0;
    letter-spacing: 0.05em;
  }
  .main-nav {
    display: flex;
    justify-content: center;
    gap: 1.5rem;
  }
  .main-nav a {
    text-decoration: none;
    color: var(--text-light-color);
    font-weight: 500;
    padding: 0.5rem 1rem;
    border-radius: var(--radius);
    transition: background-color 0.3s, color 0.3s;
  }
  .main-nav a:hover {
    color: var(--primary-color);
    background-color: var(--primary-light);
  }
  .main-nav a.current {
    color: #fff;
    background-color: var(--primary-color);
    font-weight: 700;
  }

  main { flex: 1; }
  main > p {
    color: var(--text-light-color);
    text-align: center;
    margin-bottom: 1.5rem;
  }

  /* --- ピアノキーボードのスタイル --- */
  .keyboard-section {
    background: var(--surface-color);
    border-radius: var(--radius);
    box-shadow: var(--shadow-light);
    margin: 1.5rem auto 0 auto;
    max-width: 700px;
    overflow: hidden;
    max-height: 0;
    opacity: 0;
    padding-top: 0;
    padding-bottom: 0;
    transition: max-height 0s ease-out, opacity 0.4s ease-out, padding 0.5s ease-out, margin 0.5s ease-out;
  }
  /* ▼▼▼ 変更箇所 ▼▼▼ */
  .keyboard-section.visible {
    max-height: 600px;
    opacity: 1;
    padding: 1rem;
    display: flex;
    gap: 2rem;
    align-items: center;
    justify-content: center;
    flex-wrap: wrap;
  }

  /* ▲▲▲ 変更箇所 ▲▲▲ */

  #key-fingering-display {
    display: flex;
    justify-content: center;
    align-items: center;
    min-height: 160px;
    width: 160px;
    background: var(--background-color);
    border-radius: var(--radius);
    padding: 1rem;
    border: 1px solid var(--border-color);
  }
  #key-fingering-display .card { box-shadow: none; padding: 0; background: transparent; }
  #key-fingering-display span { color: var(--text-light-color); }

  .piano { position: relative; user-select: none; width: max-content; height: 160px; }
  .white-key, .black-key {
    display: inline-block;
    cursor: pointer;
    border-radius: 4px;
    transition: background 0.2s;
  }
  .white-key {
    width: 36px;
    height: 160px;
    background: #fff;
    border: 1px solid #e0e0e0;
    position: relative;
    float: left;
  }
  .white-key.active {
    background: var(--primary-light);
    border-color: var(--primary-color);
  }
  .black-key {
    position: absolute;
    width: 24px;
    height: 100px;
    background: #333;
    z-index: 1;
  }
  .black-key.active { background: var(--primary-color); }
  .key-label {
    position: absolute;
    bottom: 8px;
    left: 0;
    width: 100%;
    text-align: center;
    font-size: 14px;
    color: var(--text-light-color);
    pointer-events: none;
  }
  
  /* --- 運指表示ボード --- */
  .board {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: 1.5rem;
    justify-items: center;
    margin-top: 2rem;
  }
  .card {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 0.5rem;
    padding: 1rem;
    background: var(--surface-color);
    border-radius: var(--radius);
    box-shadow: var(--shadow-light);
    width: 100%;
    min-height: 150px;
    transition: transform 0.2s ease, box-shadow 0.2s ease;
  }
  .card.rest-card { background: transparent; box-shadow: none; cursor: default !important; }
  .card:not(.rest-card):hover {
    transform: translateY(-4px);
    box-shadow: 0 0 0 2px var(--primary-color), var(--shadow);
  }
  .card.active {
    box-shadow: 0 0 0 3px var(--primary-color);
    transform: translateY(-2px);
  }
  .card.rest-card.active { background: var(--primary-light); box-shadow: none; }
  .card img { width: 100px; height: auto; }
  .note-label { font-weight: 500; font-size: 1rem; }

  /* --- 入力フォーム --- */
  .seq-wrapper { max-width: 600px; margin: 0 auto; text-align: center; }
  #seq-input {
    width: 100%;
    padding: 0.8rem 1rem;
    border: 1px solid var(--border-color);
    border-radius: var(--radius);
    font-size: 1rem;
    background: var(--surface-color);
    transition: border-color 0.2s, box-shadow 0.2s;
    font-family: inherit;
    resize: vertical;
    min-height: 80px;
  }
  #seq-input:focus { outline: none; border-color: var(--primary-color); box-shadow: 0 0 0 3px var(--primary-light); }
  .btn {
    margin-top: 1rem;
    padding: 0.8rem 2rem;
    border: none;
    border-radius: var(--radius);
    background: var(--primary-color);
    color: #fff;
    font-weight: 700;
    font-size: 1rem;
    cursor: pointer;
    transition: background-color 0.2s, transform 0.2s;
  }
  .btn:hover { background-color: #3a70c2; transform: translateY(-2px); }

  /* --- 移調コントロール --- */
  .transpose-controls {
    display: none;
    align-items: center;
    justify-content: center;
    gap: 1rem;
    margin-top: 1.5rem;
    background: var(--primary-light);
    padding: 1rem;
    border-radius: var(--radius);
    flex-wrap: wrap;
    max-width: 600px;
    margin-left: auto;
    margin-right: auto;
  }
  .transpose-controls .btn { margin-top: 0; }
  .transpose-controls span {
    font-size: 1.1rem;
    font-weight: 700;
    width: 100px;
    display: inline-block;
    text-align: center;
  }

  /* --- レスポンシブ --- */
  @media(max-width: 768px) {
    .container { padding: 1rem; }
    .board { grid-template-columns: repeat(3, 1fr); gap: 1rem; }
    .card img { width: 80px; }
  }
  @media(max-width: 480px) {
    .board { grid-template-columns: repeat(2, 1fr); }
  }
</style>
</head>
<body>
<header>
  <div class="container">
    <h1>Ocarina Fingering Trainer</h1>
    <nav class="main-nav">
      <a href="keyboard.html">鍵盤で探す</a>
      <a href="sequence.html" class="current">音名で入力</a>
      <a href="samples.html">サンプル曲</a>
    </nav>
  </div>
</header>
<div class="container">
  <main>
    <p>音名やドレミを入力すると運指がリアルタイムで表示されます。</p>
    <div class="seq-wrapper">
      <textarea id="seq-input" rows="4" placeholder="例: ド レ ミ ファ&#10;ソ ラ シ ド"></textarea>
      <button id="toggle-keyboard-btn" class="btn">キーボードを表示</button>
    </div>
    
    <div id="keyboard-section" class="keyboard-section">
        <div id="key-fingering-display">
          <span>キーを押してください</span>
        </div>
        <div id="piano" class="piano"></div>
    </div>
    <div id="transpose-controls" class="transpose-controls">
      <button id="transpose-down" class="btn">- Key</button>
      <span id="transpose-level">Key: 0</span>
      <button id="transpose-up" class="btn">+ Key</button>
    </div>

    <div id="board-seq" class="board"></div>
  </main>
</div>

<script>
/* ========= Web Audio & Data ========= */
let audioContext;
try { audioContext = new (window.AudioContext || window.webkitAudioContext)(); } catch (e) { console.error('Web Audio API unsupported'); }
const OCARINA_RANGE = ['A','A#','B','C','C#','D','D#','E','F','F#','G','G#','A2','A#2','B2','C2','C#2','D2','D#2','E2','F2'];
const NOTE_FREQUENCIES = {'A':440,'A#':466.16,'B':493.88,'C':523.25,'C#':554.37,'D':587.33,'D#':622.25,'E':659.25,'F':698.46,'F#':739.99,'G':783.99,'G#':830.61,'A2':880,'A#2':932.33,'B2':987.77,'C2':1046.5,'C#2':1108.73,'D2':1174.66,'D#2':1244.51,'E2':1318.51,'F2':1396.91};
const NOTE_TO_INDEX = Object.fromEntries(OCARINA_RANGE.map((n,i) => [n,i]));
const INPUT_TO_NOTE = {'ら':'A','ら#':'A#','ら♯':'A#','し':'B','ど':'C','ど#':'C#','ど♯':'C#','れ':'D','れ#':'D#','れ♯':'D#','み':'E','ふぁ':'F','ふぁ#':'F#','ふぁ♯':'F#','そ':'G','そ#':'G#','そ♯':'G#','ら2':'A2','ら#2':'A#2','ら♯2':'A#2','し2':'B2','ど2':'C2','ど#2':'C#2','ど♯2':'C#2','れ2':'D2','れ#2':'D#2','れ♯2':'D#2','み2':'E2','ふぁ2':'F2','ラ':'A','ラ#':'A#','ラ♯':'A#','シ':'B','ド':'C','ド#':'C#','ド♯':'C#','レ':'D','レ#':'D#','レ♯':'D#','ミ':'E','ファ':'F','ファ#':'F#','ファ♯':'F#','ソ':'G','ソ#':'G#','ソ♯':'G#','ラ2':'A2','ラ#2':'A#2','ラ♯2':'A#2','シ2':'B2','ド2':'C2','ド#2':'C#2','ド♯2':'C#2','レ2':'D2','レ#2':'D#2','レ♯2':'D#2','ミ2':'E2','ファ2':'F2','A':'A','A#':'A#','BB':'A#','B':'B','C':'C','C#':'C#','DB':'C#','D':'D','D#':'D#','EB':'D#','E':'E','F':'F','F#':'F#','GB':'F#','G':'G','G#':'G#','AB':'G#','A2':'A2','A#2':'A#2','BB2':'A#2','B2':'B2','C2':'C2','C#2':'C#2','DB2':'C#2','D2':'D2','D#2':'D#2','EB2':'D#2','E2':'E2','F2':'F2'};
const IMG_PATH = './img/';
const FINGERING_IMG = {'A':'fingering_A.png','A#':'fingering_As.png','B':'fingering_B.png','C':'fingering_C.png','C#':'fingering_Cs.png','D':'fingering_D.png','D#':'fingering_Ds.png','E':'fingering_E.png','F':'fingering_F.png','F#':'fingering_Fs.png','G':'fingering_G.png','G#':'fingering_Gs.png','A2':'fingering_A2.png','A#2':'fingering_As2.png','B2':'fingering_B2.png','C2':'fingering_C2.png','C#2':'fingering_Cs2.png','D2':'fingering_D2.png','D#2':'fingering_Ds2.png','E2':'fingering_E2.png','F2':'fingering_F2.png'};
const SHARP_TO_FLAT = {'A#':'Bb','C#':'Db','D#':'Eb','F#':'Gb','G#':'Ab','A#2':'Bb2','C#2':'Db2','D#2':'Eb2'};
const AMBIGUOUS_NOTE_MAP = {};
OCARINA_RANGE.forEach(note => {
  const baseWithSharp = note.replace('2', '');
  if (!AMBIGUOUS_NOTE_MAP[baseWithSharp]) AMBIGUOUS_NOTE_MAP[baseWithSharp] = [];
  AMBIGUOUS_NOTE_MAP[baseWithSharp].push(note);
});

/* ========= DOM ========= */
const pianoRoot = document.getElementById('piano');
const keyFingeringDisplay = document.getElementById('key-fingering-display');
const keyboardSection = document.getElementById('keyboard-section');
const seqInput = document.getElementById('seq-input');
const boardSeq = document.getElementById('board-seq');
const transposeControls = document.getElementById('transpose-controls');
const transposeLevel = document.getElementById('transpose-level');
const transposeUp = document.getElementById('transpose-up');
const transposeDown = document.getElementById('transpose-down');
const toggleKeyboardBtn = document.getElementById('toggle-keyboard-btn');

/* ========= 状態 ========= */
let currentSequenceIndex = null;
let originalSequence = [];
let transposition = 0;

/* ========= Audio ========= */
function playNote(freq, dur = 0.45) {
  if (!audioContext || !freq) return;
  if (audioContext.state === 'suspended') audioContext.resume();
  const osc = audioContext.createOscillator();
  const gain = audioContext.createGain();
  osc.type = 'sine';
  osc.frequency.setValueAtTime(freq, audioContext.currentTime);
  gain.gain.setValueAtTime(0.5, audioContext.currentTime);
  gain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + dur);
  osc.connect(gain); gain.connect(audioContext.destination);
  osc.start(); osc.stop(audioContext.currentTime + dur);
}

/* ========= UI Helper ========= */
function createCard(note, label) {
  const wrap = document.createElement('div');
  wrap.className = 'card';
  const lbl = document.createElement('div');
  lbl.className = 'note-label';
  lbl.textContent = label;
  if (note === 'REST') {
    wrap.classList.add('rest-card');
    lbl.style.color = 'var(--text-light-color)';
    wrap.appendChild(lbl);
    return wrap;
  }
  const img = document.createElement('img');
  img.onerror = () => { img.style.display = 'none'; lbl.style.color = '#888'; lbl.textContent += ' (画像なし)'; };
  if (note && FINGERING_IMG[note]) { img.src = IMG_PATH + FINGERING_IMG[note]; img.alt = `${note} fingering`; } else { img.style.display = 'none'; }
  wrap.appendChild(lbl); wrap.appendChild(img);
  return wrap;
}

/* --- 独立キーボード用の機能 --- */
function highlightPianoKeys(note) {
  pianoRoot.querySelectorAll('.white-key, .black-key').forEach(k => k.classList.toggle('active', k.dataset.note === note));
}

function renderSingle(note) {
  if (!(note in NOTE_FREQUENCIES)) return;
  const staffKey = SHARP_TO_FLAT[note] || note;
  highlightPianoKeys(note);
  keyFingeringDisplay.innerHTML = '';
  const card = createCard(note, staffKey.replace(/b/, '♭').replace(/#/, '♯'));
  keyFingeringDisplay.appendChild(card);
  playNote(NOTE_FREQUENCIES[note]);
}

/* --- ピアノ生成ロジック --- */
function buildPiano() {
  const wasVisible = keyboardSection.classList.contains('visible');
  if (!wasVisible) {
    keyboardSection.style.visibility = 'hidden';
    keyboardSection.classList.add('visible');
  }
  
  pianoRoot.innerHTML = '';
  const whiteKeysData = OCARINA_RANGE.filter(n => !n.includes('#'));
  const blackKeysData = OCARINA_RANGE.filter(n => n.includes('#'));
  const whiteKeyElements = {};
  const noteToDoremi = { 'C': 'ド', 'D': 'レ', 'E': 'ミ', 'F': 'ファ', 'G': 'ソ', 'A': 'ラ', 'B': 'シ' };

  whiteKeysData.forEach(noteName => {
    const el = document.createElement('div');
    el.className = 'white-key';
    el.dataset.note = noteName;
    el.addEventListener('click', () => renderSingle(noteName));
    const baseNote = noteName.replace(/[0-9]/, '');
    const doremiText = noteToDoremi[baseNote];
    if (doremiText) {
      const label = document.createElement('div');
      label.className = 'key-label';
      label.textContent = doremiText;
      el.appendChild(label);
    }
    pianoRoot.appendChild(el);
    whiteKeyElements[noteName] = el;
  });

  blackKeysData.forEach(noteName => {
    const parentWhiteKeyName = noteName.replace('#', '');
    const parentElement = whiteKeyElements[parentWhiteKeyName] || whiteKeyElements[parentWhiteKeyName.slice(0, -1)];
    if (parentElement) {
      const blackKeyElement = document.createElement('div');
      blackKeyElement.className = 'black-key';
      blackKeyElement.dataset.note = noteName;
      const whiteKeyWidth = 36;
      const blackKeyWidth = 24;
      blackKeyElement.style.left = `${parentElement.offsetLeft + whiteKeyWidth - (blackKeyWidth / 2)}px`;
      blackKeyElement.addEventListener('click', e => {
        e.stopPropagation();
        renderSingle(noteName);
      });
      pianoRoot.appendChild(blackKeyElement);
    }
  });

  if (!wasVisible) {
    keyboardSection.classList.remove('visible');
    keyboardSection.style.visibility = 'visible';
  }
}

/* ========= Sequence Mode (テキスト入力関連) ========= */
const ESCAPED_KEYS = Object.keys(INPUT_TO_NOTE).sort((a,b) => b.length - a.length).map(k => k.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'));

function transposeNote(note, step) {
  if (note === 'REST' || note === 'LINEBREAK') return note;
  const idx = NOTE_TO_INDEX[note];
  if (idx === undefined) return null;
  const newIdx = idx + step;
  if (newIdx < 0 || newIdx >= OCARINA_RANGE.length) return null;
  return OCARINA_RANGE[newIdx];
}

function selectSequenceNote(index) {
  if (index < 0 || index >= originalSequence.length) return;
  currentSequenceIndex = index;
  let cardIndex = 0;
  let dataIndex = 0;
  while(dataIndex < index) {
     if(originalSequence[dataIndex].note !== 'LINEBREAK') cardIndex++;
     dataIndex++;
  }
  const cards = boardSeq.querySelectorAll('.card');
  cards.forEach((c, i) => c.classList.toggle('active', i === cardIndex));
  const item = originalSequence[index];
  if (item.note === 'REST' || item.note === 'LINEBREAK') return;
  const tNote = transposeNote(item.note, transposition);
  if (tNote) {
    playNote(NOTE_FREQUENCIES[tNote]);
  }
}

function renderTransposedSequence() {
  boardSeq.innerHTML = '';
  if (originalSequence.length === 0) {
    transposeControls.style.display = 'none';
    return;
  }
  transposeControls.style.display = 'flex';
  transposeLevel.textContent = `Key: ${transposition > 0 ? '+' : ''}${transposition}`;
  
  originalSequence.forEach((item, index) => {
    let card;
    if (item.note === 'LINEBREAK') {
       const brEl = document.createElement('div');
       brEl.style.gridColumn = '1 / -1';
       brEl.style.height = '0';
       boardSeq.appendChild(brEl);
       return;
    }
    if (item.note === 'REST') {
      card = createCard('REST', '休');
    } else {
      const tNote = transposeNote(item.note, transposition);
      if (tNote) {
        const disp = (SHARP_TO_FLAT[tNote] || tNote).replace(/b/, '♭').replace(/#/, '♯');
        const lbl = item.lyric ? `${disp}（${item.lyric}）` : disp;
        card = createCard(tNote, lbl);
      } else {
        const lbl = item.lyric ? `音域外（${item.lyric}）` : '音域外';
        card = createCard(null, lbl);
      }
    }
    card.style.cursor = 'pointer';
    card.addEventListener('click', () => selectSequenceNote(index));
    card.addEventListener('contextmenu', e => {
      e.preventDefault();
      const currentItem = originalSequence[index];
      if (currentItem.note === 'REST' || currentItem.note === 'LINEBREAK') return;
      const currentNote = currentItem.note;
      const baseNote = currentNote.replace('2', '');
      const octaveOptions = AMBIGUOUS_NOTE_MAP[baseNote];
      if (octaveOptions && octaveOptions.length > 1) {
        const currentIndex = octaveOptions.indexOf(currentNote);
        const nextIndex = (currentIndex + 1) % octaveOptions.length;
        originalSequence[index].note = octaveOptions[nextIndex];
        renderTransposedSequence();
      }
    });
    boardSeq.appendChild(card);
  });
  if (currentSequenceIndex !== null && currentSequenceIndex < originalSequence.length) {
    selectSequenceNote(currentSequenceIndex);
  } else {
    const firstValid = originalSequence.findIndex(item => transposeNote(item.note, transposition) !== null && item.note !== 'REST' && item.note !== 'LINEBREAK');
    if (firstValid !== -1) selectSequenceNote(firstValid);
  }
}

function parseAndResolveSequence(rawText) {
  if (!rawText.trim()) return [];
  const tokenRegex = new RegExp(`(${ESCAPED_KEYS.join('|')})(?:（([^）]+)）)?|([ 　]+)|(\\n)`, 'gi');
  const matches = [...rawText.matchAll(tokenRegex)];
  if (matches.length === 0) {
    boardSeq.innerHTML = '<p style="grid-column:1/-1;color:var(--text-light-color);">認識できる音名がありませんでした。</p>';
    return [];
  }
  let intermediateSequence = matches.map(m => {
    const [_, noteToken, lyricToken, spaceToken, newlineToken] = m;
    if (newlineToken) return { note: 'LINEBREAK' };
    if (spaceToken) return { note: 'REST' };
    const noteName = (noteToken || '').toUpperCase().replace('♭', 'b').replace('♯', '#');
    const note = INPUT_TO_NOTE[noteName] || INPUT_TO_NOTE[noteToken];
    if (!note) return null;
    const potentialNotes = AMBIGUOUS_NOTE_MAP[note.replace('2','')];
    const isAmbiguous = potentialNotes && potentialNotes.length > 1 && !noteToken.includes('2') && !noteToken.includes('２');
    return { note: note, lyric: lyricToken || '', isAmbiguous: isAmbiguous, potentialNotes: potentialNotes };
  }).filter(Boolean);

  intermediateSequence.forEach((currentItem, i) => {
    if (!currentItem.isAmbiguous) return;
    let referenceNote = null;
    for (let j = i - 1; j >= 0; j--) { if (intermediateSequence[j].note !== 'REST' && intermediateSequence[j].note !== 'LINEBREAK') { referenceNote = intermediateSequence[j].note; break; } }
    if (!referenceNote) { for (let j = i + 1; j < intermediateSequence.length; j++) { if (intermediateSequence[j].note !== 'REST' && intermediateSequence[j].note !== 'LINEBREAK') { referenceNote = intermediateSequence[j].note; break; } } }
    if (referenceNote) {
      const refIndex = NOTE_TO_INDEX[referenceNote];
      if (refIndex === undefined) return;
      let bestNote = currentItem.note, minDistance = Infinity;
      currentItem.potentialNotes.forEach(pNote => {
        const distance = Math.abs(NOTE_TO_INDEX[pNote] - refIndex);
        if (distance < minDistance) { minDistance = distance; bestNote = pNote; }
      });
      currentItem.note = bestNote;
      currentItem.isAmbiguous = false;
    }
  });
  return intermediateSequence.map(item => ({ note: item.note, lyric: item.lyric || '' }));
}

function updateApp() {
    const rawText = seqInput.value;
    const newUrl = rawText.trim()
        ? `${window.location.pathname}?sequence=${encodeURIComponent(rawText)}`
        : window.location.pathname;
    history.replaceState({ sequence: rawText }, '', newUrl);
    originalSequence = parseAndResolveSequence(rawText);
    currentSequenceIndex = null;
    renderTransposedSequence();
}

/* ========= イベントリスナー ========= */
transposeUp.addEventListener('click', () => { transposition++; renderTransposedSequence(); });
transposeDown.addEventListener('click', () => { transposition--; renderTransposedSequence(); });

document.addEventListener('keydown', e => {
  if (document.activeElement === seqInput) return;
  const isLeft = e.key === 'ArrowLeft';
  const isRight = e.key === 'ArrowRight';
  if (!isLeft && !isRight) return;
  if (currentSequenceIndex === null || originalSequence.length === 0) return;
  e.preventDefault();
  const newIndex = currentSequenceIndex + (isLeft ? -1 : 1);
  if (newIndex >= 0 && newIndex < originalSequence.length) {
     let next = newIndex;
     while(next >= 0 && next < originalSequence.length) {
         const note = originalSequence[next].note;
         if (note !== 'REST' && note !== 'LINEBREAK') { selectSequenceNote(next); break; }
         next += (isLeft ? -1 : 1);
     }
  }
});

window.addEventListener('load', () => {
  buildPiano();
  const params = new URLSearchParams(window.location.search);
  const sequence = params.get('sequence');
  if (sequence) {
    seqInput.value = decodeURIComponent(sequence);
  }
  transposition = 0;
  updateApp();
});

seqInput.addEventListener('input', updateApp);

toggleKeyboardBtn.addEventListener('click', () => {
  keyboardSection.classList.toggle('visible');
  if (keyboardSection.classList.contains('visible')) {
    toggleKeyboardBtn.textContent = 'キーボードを非表示';
  } else {
    toggleKeyboardBtn.textContent = 'キーボードを表示';
    highlightPianoKeys(null);
  }
});
</script>
</body>
</html>